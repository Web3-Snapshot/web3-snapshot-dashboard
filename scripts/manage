#!/bin/bash

# This shell script is used to manage the application via simple commands
# targeting the underlying docker setup. It contains various functions to start,
# stop, and restart the application.
#
# Commands:
#   start - Starts the application
#   stop - Stops the application
#   print-vars - Prints the environment variables
#   build - Builds the containers
#   tests - Runs the tests
#   ps - Shows the running containers
#   logs - Shows the logs of the application
#   isession - Starts an interactive session
#   connect-service - Connects to a service
#   start-cert-server - Starts the certbot server on port 80
#   get-certificate - Gets a certificate
#   renew-certificate - Renews a certificate
#   help - Shows the help menu

#######################################
#####      Global variables       #####
#######################################

valid_environments=("production" "testing" "development")
required_variables=("ENVIRONMENT")

#######################################
#####      Internal functions     #####
#######################################

# Define a function to convert a relative path to an absolute path
realpath() {
    [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
}

# This function validates the environment before executing any command.
_validate_environment() {
    valid=false

    for i in "${valid_environments[@]}"; do
        if [[ "$i" == "$ENVIRONMENT" ]]; then
            valid=true
            break
        fi
    done

    if [ "$valid" = false ]; then
        echo "Variable ENVIRONMENT must be either production, testing, cypress or development."
        exit 1
    fi
}

_load_env_file() {
    # Check if the file exists
    if [ -f "$ENV_FILE" ]; then
        echo "Found an environment file: $ENV_FILE"
        # Loop through all the lines in the .env file and export them as environment variables if they are not already set.
        while read -r line || [[ -n "$line" ]]; do
            if [[ ! "$line" =~ ^# && ! "$line" =~ ^\s*$ ]]; then
                var_name=$(echo "$line" | cut -d= -f1)
                if [[ -z "${!var_name}" ]]; then
                    echo "Variable ${var_name} has not yet been set. Exporting ${line}"
                    export "${line?}"
                else
                    echo "${var_name} is already set to ${!var_name} from the environment. Skipping..."
                fi
            fi
        done <"$ENV_FILE"
    fi
    echo
}

# This function checks if the required variables are set. The variable names are passed in from the required_vars array.
_check_required_variables() {
    for var in "${required_variables[@]}"; do
        if [ -z "${var}" ]; then
            echo "Error: Required variable $var is not set."
            exit 1
        fi
    done
}

######################################
#####      Exposed functions     #####
######################################
start() {
    echo "Starting containers using environment $ENVIRONMENT"
    docker compose -f docker-compose."$ENVIRONMENT".yml run backend test -f /app/instance/db.sqlite && echo "DB found." &&
            DEBUG=$_arg_debug docker compose -f docker-compose."$ENVIRONMENT".yml up -d frontend backend db ||
        echo "Database not found. Run migrations first."
}

stop() {
    docker compose -f docker-compose."$ENVIRONMENT".yml down
}

build() {
    docker compose -f docker-compose."$ENVIRONMENT".yml build --no-cache
}

connect-service() {
    start && docker compose -f docker-compose."$ENVIRONMENT".yml exec -it "$_service" /bin/sh
}

ps() {
    docker compose -f docker-compose."$ENVIRONMENT".yml ps
}

print_vars() {
    for i in "${required_variables[@]}"; do
        echo "$i: ${!i}"
    done
}

logs() {
    docker compose -f docker-compose."$ENVIRONMENT".yml logs -f
}

tests() {
    start && docker compose -f docker-compose."$ENVIRONMENT".yml exec backend pytest tests -vvv
}


isession() {
    docker compose -f docker-compose."$ENVIRONMENT".yml run isession
}

start-cert-server() {
    docker compose -f docker-compose.certbot.yml down && \
	docker compose -f docker-compose.certbot.yml up -d nginx80
}

stop-cert-server() {
	docker compose -f docker-compose.certbot.yml down
}

get-certificate() {
	docker compose -f docker-compose.certbot.yml run --rm  certbot certonly --webroot \
		--webroot-path /var/www/certbot/ --dry-run -d www.$(DOMAIN) -d $(DOMAIN) -v
}

renew-certificate() {
	docker compose -f docker-compose.certbot.yml run --rm  certbot renew --webroot --webroot-path /var/www/certbot/
}

install_backend() {
    if [[ -z "$_arg_install_backend" ]]; then
        echo "Error: No package to install."
        exit 1
    fi

    rm -rf backend/Pipfile.lock
    start && docker compose -f docker-compose."$ENVIRONMENT".yml exec backend \
        pip install "$_arg_install_backend"
}


## Check for environment variables

# Convert the relative path to an absolute path
ENV_FILE=$(realpath ".env.$ENVIRONMENT")
# Call the function to load the environment file
_load_env_file

# Make sure that the environment maches on of the valid environments
_validate_environment

_check_required_variables

#######################################
#####      Argument Parsing       #####
#######################################

# ARG_OPTIONAL_ACTION([start],[],[Start the server],[start])
# ARG_OPTIONAL_ACTION([stop],[],[Stop the server],[stop])
# ARG_OPTIONAL_ACTION([print-vars],[],[Print variables],[print_vars])
# ARG_OPTIONAL_ACTION([build],[],[Build containers],[build])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Start up the debugging server and attach],[off])
# ARG_OPTIONAL_ACTION([tests],[],[Run pytests],[tests])
# ARG_OPTIONAL_ACTION([ps],[],[Print running containers],[ps])
# ARG_OPTIONAL_ACTION([logs],[],[Tail out logs],[logs])
# ARG_OPTIONAL_ACTION([issession],[],[Start an interactive session],[isession])
# ARG_OPTIONAL_ACTION([start-cert-server],[],[Start the certbot server on port 80],[start-cert-server])
# ARG_OPTIONAL_ACTION([get-certificate],[],[Get a certbot certificate],[get-certificate])
# ARG_OPTIONAL_ACTION([renew-certificate],[],[Renew certificate],[renew-certificate])
# ARG_OPTIONAL_SINGLE([connect-service],[],[Connect to a service],[connect-service])
# ARG_OPTIONAL_SINGLE([install-backend],[],[Install backend package])
#
# ARG_HELP([The general script's help msg])
# ARGBASH_GO()

die() {
    local _ret="${2:-1}"
    test "${_PRINT_HELP:-no}" = yes && print_help >&2
    echo "$1" >&2
    exit "${_ret}"
}

begins_with_short_option() {
    local first_option all_short_options='h'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_connect_service=
_arg_debug="off"

print_help() {
    printf '%s\n' "The general script's help msg"
    printf 'Usage: %s [--start] [--stop] [--print-vars] [--build] [--tests] [--ps] [--logs] [--isession] [--start-cert-server] [--get-certificate] [--renew-certificate] [--connect-service <service>] [-h|--help]\n' "$0"
    printf '\t%s\n' "--start: \"Start the server\""
    printf '\t%s\n' "--stop: \"Stop the server\""
    printf '\t%s\n' "--print-vars: \"Print variables"
    printf '\t%s\n' "--build: Build containers"
    printf '\t%s\n' "--debug, --no-debug: Start up the debugging server and attach (off by default)"
    printf '\t%s\n' "--tests: Run pytests"
    printf '\t%s\n' "--ps: Print running containers"
    printf '\t%s\n' "--logs: Tail out logs"
    printf '\t%s\n' "--isession: Start an interactive session"
    printf '\t%s\n' "--start-cert-server: Start the certbot server on port 80"
    printf '\t%s\n' "--get-certificate: Get a certbot certificate"
    printf '\t%s\n' "--renew-certificate: Renew certificate"
    printf '\t%s\n' "--connect-service: service to connect to (no default)"
    printf '\t%s\n' "--install-backend: Install backend package (no default)"
    printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --start)
            command=start
            ;;
        --stop)
            stop
            exit 0
            ;;
        --print-vars)
            print_vars
            exit 0
            ;;
        --build)
            build
            exit 0
            ;;
        --no-debug|--debug)
            _arg_debug="on"
            test "${1:0:5}" = "--no-" && _arg_debug="off"
            ;;
        --tests)
            tests
            exit 0
            ;;
        --ps)
            ps
            exit 0
            ;;
        --logs)
            logs
            exit 0
            ;;
        --isession)
            isession
            exit 0
            ;;
        --connect-service)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _service="$2"
            echo "Starting up $_service"
            connect-service _service
            shift
            ;;
        --connect-service=*)
            _arg_connect_service="${_key##--connect-service=}"
            ;;
        --start-cert-server)
            start-cert-server
            exit 0
            ;;
        --get-certificate)
            get-certificate
            exit 0
            ;;
        --renew-certificate)
            renew-certificate
            exit 0
            ;;
        --install-backend)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_install_backend="$2"
            install_backend "$_arg_install_backend"
            shift
            ;;
        --install-backend=*)
            _arg_install_backend="${_key##--install-backend=}"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

parse_commandline "$@"

# Commands that depend on the setting of another flag
if [ "$command" = "build" ]; then
    if [ -z "$_arg_build" ]; then
        echo "Error: Target container environment is not set."
        exit 1
    fi

    build
    exit 0
elif [ "$command" = "start" ]; then
    if [ "$_arg_debug" = "on" ]; then
        echo "Starting in debug mode"
    fi
    start
    exit 0
fi
